# -*- coding: utf-8 -*-
"""Omok.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JqmiueZ8vHdyP4GyqZj8HfAqhjwwnvBq

## Preparation
"""

import time
import math
import random

BOARD_SIZE = 19
EMPTY = 0
BLACK = 1
WHITE = -1
TIME_LIMIT = 10

DIRECTIONS = [(1, 0), (0, 1), (1, 1), (1, -1)] # 가로, 세로, 우하향 대각선, 우상향 대각선

"""## Environment"""

class Omok:
    # 게임 초기 상태
    def __init__(self):
        self.board = [[EMPTY for _ in range(BOARD_SIZE)] for _ in range(BOARD_SIZE)]
        self.cur_player = BLACK

    # 수 두기
    def make_move(self, x, y, player):
        if self.board[x][y] == EMPTY:
            self.board[x][y] = player
            return True
        return False

    # 두었던 수 되돌리기
    def undo_move(self, x, y):
        self.board[x][y] = EMPTY

    # 바둑알 둘 수 있는 위치 저장
    def get_valid_moves(self):
        moves = []
        for i in range(BOARD_SIZE):
            for j in range(BOARD_SIZE):
                if self.board[i][j] == EMPTY:
                    moves.append((i, j))

        return moves

    # 게임 종료조건
    def is_win(self, player):
        for x in range(BOARD_SIZE):
            for y in range(BOARD_SIZE):
                if self.board[x][y] == player:
                    for dx, dy in DIRECTIONS:
                        if self.count_consecutive(x, y, dx, dy, player) >= 5:
                            return True
        return False

    # 연속된 돌의 개수
    def count_consecutive(self, x, y, dx, dy, player):
        count = 0
        for i in range(5):
            nx, ny = x + i*dx, y + i*dy
            if 0 <= nx < BOARD_SIZE and 0 <= ny < BOARD_SIZE and self.board[nx][ny] == player:
                count += 1
            else:
                break
        return count

    # 바둑판 출력
    def print_board(self, board):
        for row in board:
            line = " ".join("●" if cell == BLACK else "○" if cell == WHITE else "·" for cell in row)
            print(line)

"""## AI Player"""

class AIPlayer:
    def __init__(self, player, time_limit=TIME_LIMIT):
        self.player = player
        self.time_limit = time_limit
        self.start_time = None

    def get_move(self, game: Omok):
        self.start_time = time.time()

        total_moves = sum(1 for x in range(BOARD_SIZE) for y in range(BOARD_SIZE) if game.board[x][y] != EMPTY)

        if total_moves <= 1:
            center = BOARD_SIZE // 2
            range_ = 3
            candidates = [
                (x, y)
                for x in range(center - range_, center + range_ + 1)
                for y in range(center - range_, center + range_ + 1)
                if game.board[x][y] == EMPTY ]
            return random.choice(candidates)

        depth = 1
        best_move = None

        while True:
            try:
                move = self._search_valid_moves(game, depth)
                if move is not None:
                    best_move = move
                depth += 1  # iterative deepening
            except TimeoutError:
                break

        return best_move

    def _search_valid_moves(self, game: Omok, depth):
        best_score = -math.inf
        best_move = None
        for move in game.get_valid_moves():
            if time.time() - self.start_time > self.time_limit:
                raise TimeoutError()

            x, y = move
            game.make_move(x, y, self.player)
            try:
                score = self._depth_limited_alpha_beta(game, depth - 1, -math.inf, math.inf, -self.player)
            finally:
                game.undo_move(x, y)

            if score > best_score:
                best_score = score
                best_move = move

        if best_move is not None: # best_move 찾았을 경우
            return best_move  # best_move 반환
        else: # best_move 찾지 못했을 경우
            valid_moves = game.get_valid_moves()
            return random.choice(valid_moves) # random_move 반환

    def _depth_limited_alpha_beta(self, game: Omok, depth, alpha, beta, player):
        if time.time() - self.start_time > self.time_limit:
            raise TimeoutError()

        # cutoff
        if depth == 0 or game.is_win(BLACK) or game.is_win(WHITE):
            return self._evaluate(game)

        # AI가 자신의 점수를 최대화하려는 수 탐색
        if player == self.player:
            max_eval = -math.inf
            for move in game.get_valid_moves():
                x, y = move
                game.make_move(x, y, player)

                try:
                    eval = self._depth_limited_alpha_beta(game, depth - 1, alpha, beta, -player)
                finally:
                    game.undo_move(x, y)

                max_eval = max(max_eval, eval)
                alpha = max(alpha, eval)
                if beta <= alpha:
                    break
            return max_eval

        # AI가 사용자가 AI의 점수를 최소화하려는 수 탐색ㅇ
        else:
            min_eval = math.inf
            for move in game.get_valid_moves():
                x, y = move
                game.make_move(x, y, player)
                try:
                    eval = self._depth_limited_alpha_beta(game, depth - 1, alpha, beta, -player)
                finally:
                    game.undo_move(x, y)

                min_eval = min(min_eval, eval)
                beta = min(beta, eval)
                if beta <= alpha:
                    break
            return min_eval

    def _evaluate(self, game: Omok):
        ai_score = self._evaluate_player(game, self.player)
        user_score = self._evaluate_player(game, -self.player)
        return ai_score - user_score

    def _evaluate_player(self, game: Omok, player):
        score_sum = 0
        for x in range(BOARD_SIZE):
            for y in range(BOARD_SIZE):
                if game.board[x][y] == player:
                    for dx, dy in DIRECTIONS:
                      count = game.count_consecutive(x, y, dx, dy, player)

                      # 5목
                      if (count >= 5):
                          return math.inf

                      front_blocked, back_blocked = self._is_blocked(game, count, x, y, dx, dy, player)
                      if front_blocked and back_blocked:
                          continue

                      empty = self._is_empty(game, count, x, y, dx, dy, player)
                      if (empty < 5):
                          continue

                      # 4목
                      if (count == 4):
                          if front_blocked or back_blocked:
                              score_sum += 10000
                          else:
                              return math.inf
                          continue

                      # 1, 2, 3목
                      score = 10 ** count
                      if front_blocked or back_blocked:
                          score //= 2
                      score_sum += score

        return score_sum

    # 바로 양옆이 막혀있는지 확인
    def _is_blocked(self, game: Omok, count, x, y, dx, dy, player):
        front_x, front_y = x - dx, y - dy
        back_x, back_y = x + count * dx, y + count * dy

        front_blocked = (
            not (0 <= front_x < BOARD_SIZE and 0 <= front_y < BOARD_SIZE)
            or game.board[front_x][front_y] == -player )

        back_blocked = (
            not (0 <= back_x < BOARD_SIZE and 0 <= back_y < BOARD_SIZE)
            or game.board[back_x][back_y] == -player )

        return front_blocked, back_blocked

    # 오목이 될 수 있는 가능성 확인
    def _is_empty(self, game: Omok, count, x, y, dx, dy, player):
        empty_forward = 0
        for i in range(1, 6 - count):
            nx = x + (count + i - 1) * dx
            ny = y + (count + i - 1) * dy
            if not (0 <= nx < BOARD_SIZE and 0 <= ny < BOARD_SIZE):
                break
            if game.board[nx][ny] == -player:
                break
            elif game.board[nx][ny] == EMPTY:
                empty_forward += 1

        empty_backward = 0
        for i in range(1, 6 - count):
            nx = x - i * dx
            ny = y - i * dy
            if not (0 <= nx < BOARD_SIZE and 0 <= ny < BOARD_SIZE):
                break
            if game.board[nx][ny] == -player:
                break
            empty_backward += 1

        return count + empty_forward + empty_backward

"""## Play"""

def play_game():
    game = Omok()

    while True:
        try:
            time_limit = float(input("Time limit: "))
            if time_limit <= 0:
                print("Not positive num")
                continue
            break
        except ValueError:
            print("Invalid Input")

    while True:
        choice = input("B/W:").strip().upper()
        if choice == 'B':
            human_player = BLACK
            ai_player = AIPlayer(WHITE, time_limit)
            current_player = BLACK
            break
        elif choice == 'W':
            human_player = WHITE
            ai_player = AIPlayer(BLACK, time_limit)
            current_player = BLACK
            break

    print("You can exit by typing 'exit'")
    game.print_board(game.board)

    while True:
        if game.is_win(BLACK):
            print("BLACK wins")
            break
        elif game.is_win(WHITE):
            print("WHITE wins")
            break

        if current_player == ai_player.player:
            print("AI is thinking...")
            move = ai_player.get_move(game)
            game.make_move(move[0], move[1], current_player)
            print("AI's move:",move[0], move[1])

        else:
            while True:
                move_str = input("Your move: ")
                if move_str in ["exit"]:
                    return

                try:
                    x, y = map(int, move_str.strip().split())
                    if not (0 <= x < BOARD_SIZE and 0 <= y < BOARD_SIZE):
                        print("Out of bounds!")
                        continue

                    if (game.board[x][y] != EMPTY):
                        print("Not empty!")
                        continue

                    game.make_move(x, y, current_player)
                    break

                except ValueError:
                    print("Invalid input!")
                    continue

        game.print_board(game.board)
        current_player = -current_player

"""## Start Game!"""

play_game()